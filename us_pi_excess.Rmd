---
title: 'Estimating '
author: "Dan Weinberger"
date: "4/3/2020"
output:
  html_document:
    df_print: paged
    html_document:
    toc: true
    toc_float: true
    toc_depth: 2
---

```{r, include = F}
knitr::opts_chunk$set(
  collapse = TRUE,
  echo=F,
  warning=FALSE, 
  message=FALSE,
  comment = "#>"
)
```

```{r setup}
library(ExcessILI)
library(cdcfluview)
library(reshape2)
library(ggplot2)
library(lubridate)
library(RColorBrewer)
library(plotly)
library(MMWRweek)
library(readr)
library(rjson)
library(htmlTable)
library(RSocrata)
source('./functions/ts_plot_func.R')
```

## Introduction

There is an immediate need to track the severity and impact of the ongoing epidemic of COVID-19. Even with high-quality surveillance data, estimating the number of deaths caused by a specific pathogen is a challenge. Typically, a large proportion of deaths caused by infectious diseases are not properly attributed to a specific pathogen. With the limited availability of testing for the novel coronavirus and with imperfect sensitivity of the tests, there are undoubtedly a number of deaths caused by the virus that are not counted in official tallies of the death toll of the epidemic. 

When estimating the burden of death due to pneumonia and other respiratory pathogens, it is common to compare the observed incidence of deaths ascribed to pneumonia and influenza (“P&I”) with the incidence of P&I that would be expected at that time of year. These “excess deaths” provide a crude estimate of pathogen-specific burden. 

In this study, we compare the reported number of P&I cases across the United States with the number of deaths expected in each week based on the time of year and the intensity of influenza activity. We compare these estimates of excess deaths to the reported numbers of deaths due to COVID-19 in different states and evaluate the trajectories of these increase in relation to increases in influenza-like illness that could be linked to COVID-19. These analyses provide insights into the true burden of COVID-19.




```{r}
## Download the mortality data
#pi.data.alt <- read.socrata("https://data.cdc.gov/resource/pp7x-dyj2.json")
#pi.data.alt <- pi.data.alt[pi.data.alt$geoid=='state',]
pi.data <- pi_mortality(coverage_area='state')
pi.data$percent_complete[pi.data$percent_complete > 1] <- 1
```

```{r}
plot.states <- c('CA', 'FL','GA','ID','IL', 'LA','MA','MI','MO', 'MT', 'NJ', 'NY', 'OR', 'PA', 'WA' )
```

```{r}
#TESTING DATA FORMATTING
url.test<-"https://covidtracking.com/api/v1/states/daily.json" 


json_data <- fromJSON(file=url.test)
test.dates <- as.character(sapply(json_data,'[[','date'))

test.state <- sapply(json_data,'[[','state')
testN <- sapply(json_data, '[[', 'totalTestResults')
cum.death <- sapply(json_data, '[[', 'death')
cum.death <-sapply(cum.death, function(x){ 
  if(is.null(x)){
  x <-0
  }
  return(x)
  }
  )
test.ds <- cbind.data.frame('state'=test.state,test.dates, 'cum.tests'=testN, 'cov.track.cum.death'=cum.death )
test.ds$test.dates <-as.Date(test.ds$test.dates, '%Y%m%d')
test.ds$dow <- weekdays(test.ds$test.dates)

#Look at number of test at end of week..match this to the start date
test.ds <- test.ds[test.ds$dow == 'Saturday' ,]
test.ds$test.dates <- test.ds$test.dates - 6

pop1<-read.csv('./Data/nst-est2019-01.csv')
pop1$state_name <- substring(pop1$state_name,2)
pop1$state <- state.abb[match(pop1$state_name, state.name)]
pop1$census_bureau_pop_2019 <- gsub( ',', '',pop1$census_bureau_pop_2019)
pop1$census_bureau_pop_2019 <-as.numeric(pop1$census_bureau_pop_2019)

test.ds2 <- merge(test.ds, pop1, by='state')
test.ds2$cum.test.per.capita <- test.ds2$cum.tests/test.ds2$census_bureau_pop_2019*1000
test.ds2 <- test.ds2[, c('state','cum.test.per.capita', 'test.dates','cov.track.cum.death')]

test.ds2.spl <- split( test.ds2, test.ds2$state)
test.ds2.spl <- lapply(test.ds2.spl, function(x){
  if(nrow(x)>0){
  x<-x[order(x$test.dates),]
  x$test.week.per.capita <- x$cum.test.per.capita
  x$covid.track.death    <- x$cov.track.cum.death
  
  for(i in 2: nrow(x)){
    x$test.week.per.capita[i] <- x$cum.test.per.capita[i] - x$cum.test.per.capita[i-1]
    
    x$covid.track.death[i] <- x$cov.track.cum.death[i] - x$cov.track.cum.death[i-1]
  }
  }
  return(x)
}
  )
test.ds3.spl <-do.call('rbind.data.frame', test.ds2.spl)
```

```{r}
#download the NREVSS data
nrevvs.state <- cdcfluview::who_nrevss(region = c("state"))
  
  clin <- nrevvs.state[["clinical_labs"]]
  
  data(cdcfluview::hhs_regions)
  
  cw.file <- cdcfluview::hhs_regions
  
  clin2 <- merge(clin, cw.file,
                 by.x = "region",
                 by.y = "state_or_territory")
  
  clin2.subsetvars <- 
    c('region', 'region_number',
      'year', 'week', 'wk_date',
      'total_a','total_b',
      'total_specimens')
  
  clin2 <- clin2[, clin2.subsetvars]
  
  names(clin2)[1:2] <- c("state", "hhs_region")
  
  nrevvs_hhs <- cdcfluview::who_nrevss(region = c("hhs"))
  
  clin.hhs <- nrevvs_hhs[["clinical_labs"]]
  clin.hhs.subsetvars <-
    c('region',
      'wk_date',
      "total_a",'total_b',
      'total_specimens')
  
  clin.hhs <- clin.hhs[, clin.hhs.subsetvars]
  clin.hhs$region <- as.numeric(gsub("Region ", "", clin.hhs$region))
  
  names(clin.hhs) <-
    c("hhs_region",
      "wk_date",
      "hhs_total_a",'hhs_total_b',
      'hhs_total_specimens')
  
  clin3 <- merge(clin2, clin.hhs,
                 by = c("hhs_region", "wk_date"))
  
  clin3$total_a[is.na(clin3$total_a)] <-
    clin3$hhs_total_a[is.na(clin3$total_a)]
  
  clin3$total_b[is.na(clin3$total_b)] <-
    clin3$hhs_total_b[is.na(clin3$total_b)]
  
  clin3$total_specimens[is.na(clin3$total_specimens)] <-
    clin3$hhs_total_specimens[is.na(clin3$total_specimens)]
  
  clin3$state.abb <- state.abb[match(clin3$state, state.name)]
  
  names(clin3) <-
    c("hhs_region",
      "wk_date",
      "state_name",
      "MMWRyear", "MMWRweek",
      "total_a",'total_b',
      'total_specimens',
      'total_a_hhs', "total_b_hhs",
      'total_specimens_hhs',
      "state")
  
  clin3$total_a         <- as.numeric(clin3$total_a)
  clin3$total_b         <- as.numeric(clin3$total_b)
  clin3$total_specimens <- as.numeric(clin3$total_specimens)
  clin3$flu_pct_adj     <- (clin3$total_a + clin3$total_b + 0.5) / 
    (clin3$total_specimens + 0.5)
  clin3$fluN            <- clin3$total_a + clin3$total_b + 0.5
  clin3$flu.var         <- clin3$flu_pct_adj
  
  clin4<-clin3[,c('state','flu_pct_adj', 'wk_date')]
  
  clin4.lag1<-clin4
  clin4.lag1$wk_date <- clin4$wk_date + days(7)
  names(clin4.lag1) <-c('state','flu_pct_adj_lag1','wk_date')
  
  clin4.lag2<-clin4
  clin4.lag2$wk_date <- clin4$wk_date + days(14)
   names(clin4.lag2) <-c('state','flu_pct_adj_lag2','wk_date')
   
clin4.lags <- merge(clin4, clin4.lag1, by=c('state','wk_date'))
clin4.lags <- merge(clin4.lags, clin4.lag2, by=c('state','wk_date'))


```

```{r, include=F}
#Format and fill mssings with 0s

pi.data$state <- state.abb[match(pi.data$region_name, state.name)]
pi.data$state[pi.data$region_name == 'New York City'] <- 'NYC'
spl1<-split(pi.data, pi.data$state)
min.state <- lapply(spl1, function(x){ x$miss.x<-min(x$total_pni)
return(x)
                })
pi.data.clean <- do.call('rbind.data.frame',min.state)
pi.data.clean <- pi.data.clean[!is.na(pi.data.clean$miss.x),]

pi.data.clean2<- merge( pi.data.clean,clin4.lags, by.x=c('wk_start', 'state'), by.y=c('wk_date','state'))

pi.data.clean2<- pi.data.clean2[order(pi.data.clean2$state, pi.data.clean2$wk_end),]
```

```{r, eval=F}
#What is most appropriate lag to use for NREVSS data?
pi.data.clean2.spl <- split(pi.data.clean2, pi.data.clean2$state)
cor.lags <- sapply(pi.data.clean2.spl, function(x){
   cor(x[,c("percent_pni","flu_pct_adj",'flu_pct_adj_lag1','flu_pct_adj_lag2')])
 }, simplify='array')
matplot(cor.lags['percent_pni',-1,], type='l')

#Is lag of 0,1,or 2 the best?...shows 1 weeks lag best in 20 states,  2 week lag best in 3 states
table(apply(cor.lags['percent_pni',-1,],2, function(x) which(max(x)==x)))

states.cdc <- unique(pi.data.clean2$state)

```

```{r, include=F}
#Run analysis
excess_deaths1.adjusted <-
  excessCases(ds = pi.data.clean2,
              datevar       = "wk_start",
              statevar      = "state",
              denom.var     = "all_deaths",
              adj.flu       = "flu_pct_adj_lag1",
              #covs=c("flu_pct_adj", "flu_pct_adj_lag1", "flu_pct_adj_lag2"),
              use.syndromes = c("total_pni"),
              extrapolation.date = "2020-03-01",
              time.res='week')
```


```{r, echo=F}
 #dashboardPlot(excess_deaths1.adjusted)
```


```{r}
### Extract the quantities of interest

#Which syndrome do you want to plot, and over what time range?

syndrome.select <- 'total_pni' #which syndrome do you want to plot?
n.days<-52  #How many days to plot?
ds <- excess_deaths1.adjusted
```
 
```{r}
#Extract the data needed to plot from the results

dates1 <-
  ds[[1]][[1]][[1]]$date
  
unexplained.cases <-
  excessExtract(ds = ds,
                syndrome = syndrome.select,
                extract.quantity = "unexplained.cases")

unexplained.log.rr <-
  excessExtract(ds = ds,
                syndrome = syndrome.select,
                extract.quantity = "resid1")

denom <-
  excessExtract(ds = ds,
                syndrome = syndrome.select,
                extract.quantity = "denom")


upi <-
  excessExtract(ds = ds,
                syndrome = syndrome.select,
                extract.quantity = "upi")

lpi <-
  excessExtract(ds = ds,
                syndrome = syndrome.select,
                extract.quantity = "lpi")

obs <-
  excessExtract(ds = ds,
                syndrome = syndrome.select,
                extract.quantity = "y")

pred<-  excessExtract(ds = ds,
                syndrome = syndrome.select,
                extract.quantity = "pred")

rr <-  excessExtract(ds = ds,
                syndrome = syndrome.select,
                extract.quantity = "resid1")

excess_deaths <- excessExtract(ds = ds,
                syndrome = syndrome.select,
                extract.quantity = "unexplained.cases")
```

## Figure 1: Observed weekly death rate vs seasonal baseline (+/-95% Prediction Interval) 
 
```{r}
n.days <- 52
select.indices <- (length(dates1)-n.days):length(dates1)
dates<-dates1[select.indices]
states <- dimnames(pred)[[2]]
ages <- dimnames(pred)[[3]]
```

The black line shows the observed proportion of deaths that were due to Pneumonia & Influenza (P&I) per week. The red line and shaded area represent the 95% Prediction Interval. The latest data is for the week ending `r  max(dates1)+7`.

```{r, fig.width=6, fig.height=8}

  par(mfrow=c(5,3), mar=c(2,4,2,1))

plot.state.indices <- which(dimnames(pred)[[2]] %in% plot.states )
for(i in plot.state.indices){
  for(j in 1:dim(pred)[3]){
    y.range1<-range(c( pred[select.indices,i,j]/denom[select.indices,i,j],obs[select.indices,i,j]/denom[select.indices,i,j], upi[select.indices,i,j]/denom[select.indices,i,j],0))
      state.name.plot <-  state.name[match(states[i],state.abb)]

  plot(dates,
       pred[select.indices,i,j]/denom[select.indices,i,j],
       type='l',
       col='red',
       ylim=y.range1,
       bty='l',
       xlab='',
       ylab='Proportion',
       #main=paste(states[i])
       )
  
  text(x=as.Date('2019-03-01'),y=0.005, state.name.plot, pos=4)

  points(dates,
         obs[select.indices,i,j]/denom[select.indices,i,j],
         type='l',
         col='black')

  polygon(c(dates,
            rev(dates)),
          c(lpi[select.indices,i,j]/denom[select.indices,i,j],
            rev(upi[select.indices,i,j]/denom[select.indices,i,j])),
          col = rgb(1, 0, 0, alpha = 0.1),
          border = NA)
  }
}
```

## Figure 2: Observed deaths/expected deaths by state

```{r, echo=F}
rr2<-rr[,,1]
date.mmwrdates <- mmwr_week(dates1)
mmwr.epiyr<- date.mmwrdates$mmwr_year
mmwr.epiyr[date.mmwrdates$mmwr_week<=26] <- mmwr.epiyr[date.mmwrdates$mmwr_week<=26] - 1

mmwr.epiwk <- date.mmwrdates$mmwr_week
mmwr.epiwk[date.mmwrdates$mmwr_week>=27]<-date.mmwrdates$mmwr_week[date.mmwrdates$mmwr_week>=27] - 52
mmwr.epiwk <- mmwr.epiwk +26
check<-cbind.data.frame(date.mmwrdates,mmwr.epiwk, mmwr.epiyr)
```

These plots show the Observed/Expected number of deaths due to pneumonia and influenza in each week for the 2019-20 year (red) compared to previous years (gray). Values close to 1 indicate that the values for that week are close to what would be expected based on the time of year and influenza activity.

```{r, fig.width=6, fig.height=8}

  par(mfrow=c(5,3), mar=c(2,4,2,1))
plot.state.indices <- which(dimnames(pred)[[2]] %in% plot.states )

for(i in plot.state.indices){
    y.range1<-c(0,2)
    ds2<-cbind.data.frame('epiwk'=mmwr.epiwk,'epiyr'=mmwr.epiyr, rr=rr2[,i])
    ds2.c<-dcast(ds2, epiwk~epiyr, value.var='rr', fun.aggregate = mean)
    cols1<-c(rep('grey',(ncol(ds2.c)-2) ),'red')
    matplot(ds2.c$epiwk         ,
       exp(ds2.c[,-1]),
       type='l',
       col=cols1,
       ylim=y.range1,
       bty='l',
       lty=1,
       ylab='Observed/Expected',
       main=paste(states[i]))
    abline(h=1, col='black')
    }
```



```{r, echo=F, eval=F}
## excess deaths

excess_deaths2 <- excess_deaths[dates1 >= as.Date('2020-02-02'),,1]
excess_deaths.state <- apply(excess_deaths2,2,sum)
cumsum_excess_deaths_state <- apply(excess_deaths2,2,cumsum)
#matplot(cumsum_excess_deaths_state, type='l', bty='l')

```

## Figure 3: Reported number of COVID-19 deaths,compared with the excess deaths due to pneumonia and influenza in each week, by state. 
The blue line shows the number of excess P&I cases, the red solid line shows the reported number of COVID-19 deaths for the same week (as compiled by the Johns Hopkins CSEE), and the dotted red line shows the reported COVID-19 deaths for weeks in which the CDC data were not yet available. Excess P&I estimates from recent weeks are adjusted for incomplete records using the "percent_complete" variable.

```{r}
jh1.url <- "https://raw.githubusercontent.com/CSSEGISandData/COVID-19/master/csse_covid_19_data/csse_covid_19_time_series/time_series_covid19_deaths_US.csv"
jh1<-as.data.frame(read_csv(url(jh1.url)))
jh1 <- jh1[jh1$iso2=='US',]
jh1.m <- melt(jh1[, c(6:7,13:ncol(jh1))], id.vars=c('Admin2',"Province_State"))
jh1.m$variable <-as.Date(jh1.m$variable, '%m/%d/%y')

#Aggregate across the admin2 regions by day
jh2 <- aggregate( jh1.m$value, by=list('date'=jh1.m$variable, 'state'=jh1.m$Province_State), FUN=sum, na.rm=T)
names(jh2) <- c('date','state', 'cum.deaths')

jh2.spl <- split(jh2, jh2$state)
jh2.spl <-lapply(jh2.spl, function(x){
  x$deaths<-x$cum.deaths
  for(i in 2:nrow(x)){
    x$deaths[i] <- x$cum.deaths[i] - x$cum.deaths[(i-1)]
  }
  return(x)
})
jh2 <- do.call('rbind.data.frame', jh2.spl)
jh2$state <- state.abb[match(jh2$state, state.name)]

#round date to sunday
jh2$date <-floor_date(jh2$date, 'week')

jh2.agg<- aggregate( jh2$deaths, by=list('state'=jh2$state, 'date'=jh2$date), FUN=sum)
names(jh2.agg) <- c('state', 'date', 'deaths')

excess_deaths.df <- cbind.data.frame('date'=dates1,excess_deaths[,,1])
excess_deaths.m <- melt(excess_deaths.df, id.vars =c('date'))
names(excess_deaths.m) <-c('date','state','excess_pi')

excess_deaths.upi.df <- cbind.data.frame('date'=dates1,  (obs[,,1]-lpi[,,1] ))
excess_deaths.upi.m <- melt(excess_deaths.upi.df, id.vars =c('date'))
names(excess_deaths.upi.m) <-c('date','state','excess_deaths.upi')

excess_deaths.lpi.df <- cbind.data.frame('date'=dates1,(obs[,,1]-upi[,,1]) )
excess_deaths.lpi.m <- melt(excess_deaths.lpi.df, id.vars =c('date'))
names(excess_deaths.lpi.m) <-c('date','state','excess_deaths.lpi')

total_pi_df <- cbind.data.frame('date'=dates1,(obs[,,1]) )
total_pi_df.m <- melt(total_pi_df, id.vars =c('date'))
names(total_pi_df.m) <-c('date','state','total_pi')

#states.cdc <- unique(excess_deaths.m$state)
jh3 <- merge(jh2.agg, excess_deaths.m, by=c('state','date') , all=T)
jh3 <- merge(jh3, excess_deaths.lpi.m, by=c('state','date') , all=T)
jh3 <- merge(jh3, excess_deaths.upi.m, by=c('state','date') , all=T)
jh3 <- merge(jh3, total_pi_df.m, by=c('state','date') , all=T)
jh3 <-jh3[jh3$state %in% states.cdc,]

jh3 <- merge( jh3, pi.data[c('state', 'wk_start','percent_complete')], by.x=c('state','date') , by.y=c('state','wk_start'), all=T)

jh3 <- jh3[jh3$date >= as.Date('2020-01-01'),]
jh3$deaths[is.na(jh3$deaths)] <- 0

jh3 <- merge(jh3, test.ds3.spl, by.x=c('state','date'), by.y=c('state','test.dates'), all=T)
jh3$covid.track.death[is.na(jh3$covid.track.death)] <- 0

jh3 <- jh3[ !is.na(jh3$deaths), ]

#Only plot out to 1 week ahead of the US P&I data
jh3 <- jh3[ jh3$date <= max(pi.data$wk_start +7),]

```

```{r, fig.width=6, fig.height=6}
#par(mfrow=c(5,3), mar=c(2,3,1,2))
#could use 'states.cdc' or plot.states
#ts.plot.func(ds.plot=jh3, death.var='deaths' #,states.plot=plot.states )


```
```{r, fig.width=6, fig.height=6}
## Alternate Fig 3: covidtracking.com data

par(mfrow=c(5,3), mar=c(2,4,1,2))
ts.plot.func(ds.plot=jh3, death.var='covid.track.death' ,states.plot=plot.states )


```
Count number of excess cases since Jan 1 to most recent weke when P&I data available
```{r}
count.excess <-jh3[jh3$date >= as.Date('2020-01-01') & jh3$date <=max(pi.data$wk_end) &jh3$state %in% states.cdc,]
count.excess$excess_pi_adj <-count.excess$excess_pi/count.excess$percent_complete
count.excess$total_pi_adj <-count.excess$total_pi/count.excess$percent_complete
count.excess$approx.var <- ((count.excess$excess_deaths.upi -count.excess$excess_pi)/2)^2/count.excess$percent_complete
count.excess2 <- aggregate(count.excess[,c('excess_pi','total_pi','covid.track.death','approx.var')], by=list('state'=count.excess$state) ,FUN=sum)

count.excess2$exces_ci_ucl <- round(count.excess2$excess_pi + 1.96*sqrt(count.excess2$approx.var))

count.excess2$exces_ci_lcl <- round(count.excess2$excess_pi - 1.96*sqrt(count.excess2$approx.var))

count.excess2$excess_pi_ci <- paste0(round(count.excess2$excess_pi), '(',  count.excess2$exces_ci_lcl, ', ', count.excess2$exces_ci_ucl,')'  ) 


count.excess3 <- count.excess2[, c('state','total_pi','excess_pi_ci' ,'covid.track.death')]

last.date.format<-max(pi.data$wk_end)
last.date.format<-format(last.date.format,
                         "%b %d, %Y")

htmlTable(count.excess3, caption=paste0('Observed and Excess deaths due to pneumonia & influenza, and COVID-19, from January 5, 2020 through ', last.date.format))
```


```{r}
## And finally,  use the NCHS COVID death data
#(Not yet available with state-level resolution)
#cdc.covid.url<- "https://data.cdc.gov/resource/hc4f-j6nb.json"
```


## Figure 4: Compare Excess P&I mortality vs Excess ILI

Here we compare the observed vs expected number of deaths due to pneumonia and influenza in each week compare to the observed vs expected number of outpatient visits for influenza-like illness (ILI) in each week. we would expect ILI (blue line) to increase earlier than deaths (red line)
```{r, include=F}
ili.data <- ilinet(region = c("state"))
ili.data$state <- state.abb[match(ili.data$region, state.name)]
ili.data       <- ili.data[, c("state", "week_start", "ilitotal", "total_patients")]
ili.data       <- ili.data[!is.na(ili.data$total_patients),]
ili.data.spl   <- split(ili.data, ili.data$state)

min<-sapply(ili.data.spl, function(x)  min(x$total_patients))

state.select<-names(min)[which(min>0) ]
ili.data <- ili.data[ili.data$state %in% state.select,]
## Run the main analysis function, adjusting for flu using NREVSS data
excess_cases1 <-
  excessCases(ds = ili.data,
              datevar       = "week_start", 
              statevar      = "state",
              denom.var     = "total_patients",
              adj.flu       = "auto",
              use.syndromes = c("ilitotal"),
              extrapolation.date = "2020-03-01",
              time.res='week')

dates.ili <-
  excess_cases1[[1]][[1]][[1]]$date
  
rr.ili <-  excessExtract(ds = excess_cases1,
                syndrome = "ilitotal",
                extract.quantity = "resid1")
rr2.ili <- rr.ili[,,1]

date.mmwrdates.ili <- mmwr_week(dates.ili)
mmwr.epiyr.ili<- date.mmwrdates.ili$mmwr_year
mmwr.epiyr.ili[date.mmwrdates.ili$mmwr_week<=26] <- mmwr.epiyr.ili[date.mmwrdates.ili$mmwr_week<=26] - 1

mmwr.epiwk.ili <- date.mmwrdates.ili$mmwr_week
mmwr.epiwk.ili[date.mmwrdates.ili$mmwr_week>=27]<-date.mmwrdates.ili$mmwr_week[date.mmwrdates.ili$mmwr_week>=27] - 52
mmwr.epiwk.ili <- mmwr.epiwk.ili +26
```

```{r, fig.width=8, fig.height=7}
common.states <- intersect(colnames(rr2), colnames(rr2.ili))
rr2.comp <- rr2[,common.states]
rr2.ili.comp <- rr2.ili[,common.states] 
  par(mfrow=c(4,4))

for(i in 1:length(common.states)){
    y.range1<-c(0,2)
    ds2<-cbind.data.frame('epiwk'=mmwr.epiwk,'epiyr'=mmwr.epiyr, rr=rr2.comp[,i])
    ds2.c<-dcast(ds2, epiwk~epiyr, value.var='rr', fun.aggregate = mean)
    cols1<-c(rep('grey',(ncol(ds2.c)-2) ),'red')
    plot(ds2.c$epiwk         ,
       exp(ds2.c[,'2019']),
       type='l',
       col='red',
       ylim=y.range1,
       bty='l',
       lty=1,
       ylab='Observed/Expected',
       main=paste(common.states[i], ' Deaths(red),','ILI(blue)' ))

  es2<-cbind.data.frame('epiwk'=mmwr.epiwk.ili,'epiyr'=mmwr.epiyr.ili, rr=rr2.ili.comp[,i])
    es2.c<-dcast(es2, epiwk~epiyr, value.var='rr', fun.aggregate = mean)
     points(es2.c$epiwk         ,
       exp(es2.c[,'2019']), type='l', col='blue')
    abline(h=1, col='black')
}

```

## Supplementary figure: Excess all-cause deaths

Now instead of modeling the proportion of deaths that were due to pneumonia and influenza, we will model all-caused deaths
```{r}
#Run analysis
pi.data.clean2$one <- 1
pi.data.clean2$percent_complete.adj <-pi.data.clean2$percent_complete - 0.5
excess_deaths1.ac <-
  excessCases(ds = pi.data.clean2,
              datevar       = "wk_start",
              statevar      = "state",
              denom.var     = "percent_complete.adj",
              adj.flu       = "flu_pct_adj_lag1",
              #covs=c("flu_pct_adj", "flu_pct_adj_lag1", "flu_pct_adj_lag2"),
              use.syndromes = c("all_deaths"),
              extrapolation.date = "2020-03-01",
              time.res='week')
```

```{r}
ds <- excess_deaths1.ac
syndrome.select <- 'all_deaths'
excess_deaths.ac <- excessExtract(ds = excess_deaths1.ac,
                syndrome = 'all_deaths',
                extract.quantity = "unexplained.cases")
dates1.ac <-
  ds[[1]][[1]][[1]]$date
  
unexplained.cases.ac <-
  excessExtract(ds = excess_deaths1.ac,
                syndrome = syndrome.select,
                extract.quantity = "unexplained.cases")

unexplained.log.rr.ac <-
  excessExtract(ds = excess_deaths1.ac,
                syndrome = syndrome.select,
                extract.quantity = "resid1")

denom.ac <-
  excessExtract(ds = excess_deaths1.ac,
                syndrome = syndrome.select,
                extract.quantity = "denom")


upi.ac <-
  excessExtract(ds = excess_deaths1.ac,
                syndrome = syndrome.select,
                extract.quantity = "upi")

lpi.ac <-
  excessExtract(ds = excess_deaths1.ac,
                syndrome = syndrome.select,
                extract.quantity = "lpi")

obs.ac <-
  excessExtract(ds = excess_deaths1.ac,
                syndrome = syndrome.select,
                extract.quantity = "y")

pred.ac<-  excessExtract(ds = excess_deaths1.ac,
                syndrome = syndrome.select,
                extract.quantity = "pred")

rr.ac <-  excessExtract(ds = excess_deaths1.ac,
                syndrome = syndrome.select,
                extract.quantity = "resid1")

```

```{r}
# compare excess all-cause deaths with excess P&I deaths

dates.select <- which(dates1 >= as.Date('2020-01-01'))
#plot( excess_deaths[dates.select,,1],excess_deaths.ac[dates.select,,1])

```

The black line shows the observed number of *all* deaths per week, regardless of cause. The red line and shaded area represent the 95% Prediction Interval. The latest data is for the week ending `r  max(dates1)+7`. Note that these are **adjusted** for percent completeness of the data. There are no obvious jumps in all-cause mortality, even in Washington State

```{r, fig.width=8, fig.height=7}

  par(mfrow=c(4,4))

for(i in 1:dim(pred.ac)[2]){
  for(j in 1:dim(pred.ac)[3]){
    y.range1<-range(c( pred.ac[select.indices,i,j]/denom.ac[select.indices,i,j],obs.ac[select.indices,i,j]/denom.ac[select.indices,i,j], upi.ac[select.indices,i,j]/denom.ac[select.indices,i,j],0))
  plot(dates,
       pred.ac[select.indices,i,j]/denom.ac[select.indices,i,j],
       type='l',
       col='red',
       ylim=y.range1,
       bty='l',
       ylab='Proportion',
       main=paste(states[i],ages[j]))

  points(dates,
         obs.ac[select.indices,i,j]/denom.ac[select.indices,i,j],
         type='l',
         col='black')

  polygon(c(dates,
            rev(dates)),
          c(lpi.ac[select.indices,i,j]/denom.ac[select.indices,i,j],
            rev(upi.ac[select.indices,i,j]/denom.ac[select.indices,i,j])),
          col = rgb(1, 0, 0, alpha = 0.1),
          border = NA)
  }
}
```

## Supp Figure: Extract official data directly from FL 
This shows that the Johns Hopkins data  are off by ~ 1 week in the date assignments compared to Florida official stats. The Florida data records the 'date case counted', so it is possible this date is not date of death but rather the date when the case was recognized.

```{r}
library(pdftools)
library(readr)
library(gsubfn)
fl_text <-pdf_text("./Data/covid-19-data---daily-report-2020-04-06-1657.pdf")
fl1<-read_lines(fl_text)
death.start <- grep('Death    County         Age Gender', fl1 )
death.start.gap <-death.start +3

fl2 <-fl1[death.start.gap[1] : (death.start.gap[1]+300)]
fl.dates <- strapplyc(fl2, "[0-9/]{8,}", simplify = TRUE)
fl.dates <- unlist(fl.dates)
fl.dates <- as.Date(fl.dates, '%m/%d/%y')
fl3 <-cbind.data.frame('date'=fl.dates,'deaths'=rep(1, length(fl.dates)))
fl3$wkdate <- floor_date(fl3$date, 'week')
fl4 <- aggregate(fl3[,'deaths'], by=list('date'=fl3$wkdate), FUN=sum )
names(fl4) <- c('date', 'official_deaths')

fl5 <- merge(jh3, fl4, by='date', all=T)
fl5 <-fl5[fl5$state=='FL',]
fl5 <-fl5[!is.na(fl5$state),]

par(mfrow=c(1,1))
states.cdc <-'FL'
y2.range.test <- range(fl5$test.week.per.capita, na.rm=T)
for(i in 1:length(states.cdc)){
    ds.select <- fl5[fl5$state==states.cdc[i],]
    y.range1<-range(c(ds.select$covid.track.death, ds.select$excess_pi/ds.select$percent_complete), na.rm=T)
    ds.select$death.early <- ds.select$covid.track.death
    ds.select$death.early[is.na(ds.select$excess_pi)] <- NA
    par(new=FALSE)
    plot(ds.select$date         ,
       ds.select$covid.track.death,
       type='l',
       col='red',
       ylim=c(0,max(y.range1)),
       bty='l',
       lty=3,
       ylab='N Deaths',
       xlab='Date',
       main=paste(states.cdc[i] ))
    
       points(ds.select$date         ,
       ds.select$death.early, type='l', col='red',
       lty=1, lwd=2)
       
      points(ds.select$date         ,
       ds.select$deaths, type='l', col='purple',#JH data
       lty=1, lwd=2)
       
      points(ds.select$date         ,
       ds.select$official_deaths, type='l', col='orange',
       lty=1, lwd=2)

       points(ds.select$date         ,
       ds.select$excess_pi/ds.select$percent_complete, type='l', col='blue', lwd=2)
    abline(h=1, col='black')
    
    par(new=TRUE)
   plot(ds.select$date, ds.select$test.week.per.capita, ylim=y2.range.test, type='l', lty=2, lwd=0.5, col='gray', yaxt='n',xaxt='n', ylab='', xlab='', bty='l')
   axis(side=4,at=c(0,1,2,3,4,5) , labels=F)
 mtext("Tests per 1000", side=4, line=0.2, col='gray', cex=0.75)
    
}

```

## Supp Figure; Fig 1 Observed vs Expected P&I deaths for *all* states
```{r, fig.width=8, fig.height=7}

  par(mfrow=c(4,4))

for(i in 1:dim(pred)[2]){
  for(j in 1:dim(pred)[3]){
    y.range1<-range(c( pred[select.indices,i,j]/denom[select.indices,i,j],obs[select.indices,i,j]/denom[select.indices,i,j], upi[select.indices,i,j]/denom[select.indices,i,j],0))
  plot(dates,
       pred[select.indices,i,j]/denom[select.indices,i,j],
       type='l',
       col='red',
       ylim=y.range1,
       bty='l',
       ylab='Proportion',
       main=paste(states[i],ages[j]))

  points(dates,
         obs[select.indices,i,j]/denom[select.indices,i,j],
         type='l',
         col='black')

  polygon(c(dates,
            rev(dates)),
          c(lpi[select.indices,i,j]/denom[select.indices,i,j],
            rev(upi[select.indices,i,j]/denom[select.indices,i,j])),
          col = rgb(1, 0, 0, alpha = 0.1),
          border = NA)
  }
}
```


## Supp figure: Fig 2 for all states.
```{r, fig.width=8, fig.height=7}

  par(mfrow=c(4,4), mar=c(2,4,2,1))
plot.state.indices <- which(dimnames(pred)[[2]] %in% states.cdc )

for(i in plot.state.indices){
    y.range1<-c(0,2)
    ds2<-cbind.data.frame('epiwk'=mmwr.epiwk,'epiyr'=mmwr.epiyr, rr=rr2[,i])
    ds2.c<-dcast(ds2, epiwk~epiyr, value.var='rr', fun.aggregate = mean)
    cols1<-c(rep('grey',(ncol(ds2.c)-2) ),'red')
    matplot(ds2.c$epiwk         ,
       exp(ds2.c[,-1]),
       type='l',
       col=cols1,
       ylim=y.range1,
       bty='l',
       lty=1,
       ylab='Observed/Expected',
       main=paste(states[i]))
    abline(h=1, col='black')
    }
```

